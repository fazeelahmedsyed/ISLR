x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
}
cacheSolve <- function (x = makeCacheMatrix(num = 1:4 , ncol = 2, nrow = 2),...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
a
makeCacheMatrix(a)
cacheSolve(a)
makeCacheMatrix <- function (x = matrix(),...) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
}
cacheSolve <- function (x = makeCacheMatrix(1:4 , nrow = 2, ncol = 2),...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
makeCacheMatrix(a)
cacheSolve(a)
p <- 2
q <- function() x
q(3)
pakora <- 2
quora <- function() x
quora(3)
quora ()
pakora <- 2
quora <- function() pakora
quora(3)
quora()
pakora <- 2
quora <- function() {pakora}
quora()
makeCacheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
}
cacheSolve <- function (x = makeCacheMatrix(1:4 , nrow = 2, ncol = 2),...) {
inv <- x$getinverse
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
a <- makeCacheMatrix(1:4)
a
cacheSolve(a)
makeCacheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
}
cacheSolve <- function (x = makeCacheMatrix(1:4 , nrow = 2, ncol = 2),...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
a <- makeCacheMatrix(1:4)
cacheSolve(a)
cacheSolve(a)
makeCacheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
listoo <- list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
listoo
}
cacheSolve <- function (x = makeCacheMatrix(1:4 , nrow = 2, ncol = 2),...) {
inv <- x$getinverse
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
makeCacheMatrix(1:4)
cacheSolve(a)
message("Retrieving cached inverse")
makeCacheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
listoo <- list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
listoo
}
cacheSolve <- function (x = makeCacheMatrix(1:4 , nrow = 2, ncol = 2),...) {
inv <- x$getinverse
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
?message
makeCacheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
listoo <- list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
listoo
}
cacheSolve <- function (x = makeCacheMatrix(1:4 , nrow = 2, ncol = 2),...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
cacheSolve(makeCacheMatrix(1:4))
?matrix
makeCacheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
listoo <- list(set = set, get = get, setinverse = setinverse, getinverse = getinverse  )
listoo
}
cacheSolve <- function (x = makeCacheMatrix(),...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
cacheSolve(makeCacheMatrix(1:4))
cacheSolve(makeCacheMatrix(1:4))
?trycatch
?tryCatch
?solve
makeCacheMatrix <- function (x = matrix()) {
inv <- NULL
set <- function (y = matrix()) {
x <<- y
inv <<- NULL}
get <- function (){
x}
setinverse <- function(i) {
inv <<- i}
getinverse <- function() {
inv }
list <- list(set=set, get=get, setinverse=setinverse, getinverse=getinverse)
}
cacheSolve <- function (x,...) {
inv <- x$getinverse()
if(!is.null(inv)) {
message("Retrieving cached inverse")
return(inv)}
else{
mat <- x$get()
inv <- solve(mat)
x$setinverse(inv)
inv}
}
m <- rbind(c(1,-1/4),c(-1/4,1))
makeCacheMatrix(m)
f<- makeCacheMatrix(m)
cacheSolve(f)
version
getwd()
R.home()
Sys.getenv("PATH")
R.home()
Sys.getenv("PATH")
path.expand()
Sys.getenv()
Sys.getenv("MySQL_HOME")
install.packages('RMySQL', type = 'source')
library(MySQL)
Sys.getenv()
install.packages('RMySQL', type = 'source')
Sys.getenv()
?Sys.setenv
Sys.getenv()
Sys.getenv()
install.packages("RMySQL", type = "source")
library(RMySQL)
library("RMySQL")
Sys.getenv()
install.packages("RMySQL", type = "source")
library(RMySQL)
library(swirl)
swirl()
size_gb <- size_mb/2^10
View(cran2)
View(cran3)
mutate(cran3, size_mb = size/2^20, size_gb = size_mb/2^10)
View(cran3)
mutate(cran3, correct_size = size + 1000)
summarize(cran, avg_bytes = mean(size))
library(dplyr)
cran <- tbl_df(mydf)
rm("mydf")
cran
?group_by
by_package <- group_by(cran, "package")
by_package <- group_by(cran, package)
by_package
summarize(mean(size))
summarize(by_package, mean(size))
submit()
by_package
View(by_package)
View(by_package)
?n_distinct()
submit()
sumbit
submit
submit()
submit()
quit()
quit()
?connections
quit()
setwd("~/Coursera")
dir()
?formatC()
setwd("C:\Users\Dell\Documents\ISLR")
setwd("C://Users//Dell//Documents//ISLR")
getwd()
setwd("~/Coursera")
setwd("~/Documents")
setwd("C://Users//Dell//Documents")
mkdir("UMT")
?mkdir()
Library(MASS)
install.packages("MASS")
#This function is for Classification Methods LR,LDA,QDA and KNN.
#Loading Libraries
library(ISLR)
#Preparing Dataset
Smarket <- Smarket
a <- c("The year that the observation was recorded","Percentage return for previous day","Percentage return for 2 days previous","Percentage return for 3 days previous","Percentage return for 4 days previous","Percentage return for 5 days previous","Volume of shares traded (number of daily shares traded in billions)","Percentage return for today","A factor with levels Down and Up indicating whether the market had a positive or negative return on a given day")
Smarket_desc <- data.frame(cbind(colnames(Smarket),a))
colnames(Smarket_desc) <- c("variable","Variable Description")
rm(a)
#Creating Correlation matrix and identifying highly correlated variables
Smarket_cor <- cor(Smarket[,-9])
sort(Smarket_cor, decreasing = T)
which(Smarket_cor > 0.5 & Smarket_cor < 1, arr.ind = T)
colnames(Smarket_cor)[c(1,7)]
#Observing the highly correlated variables
plot(Smarket$Volume, col = "dark grey", pch = 4)
print("Volume appears to increase with time")
#Running Logistic Regression on the Dataset
glm.fit <- glm(Direction ~. -Year -Today, data = Smarket, family = binomial)
summary(glm.fit)
summary(glm.fit)$coefs
summary(glm.fit)$coef
names(summary(glm.fit))
summary(glm.fit)$coefficients
summary(glm.fit)$contrasts
contrasts(summary(glm.fit))
summary(glm.fit)
summary(glm.fit)$coefficients[,4]
summary(glm.fit)$coefficients[4,]
summary(glm.fit)$coefficients
contrasts(Direction)
contrasts(Smarket$Direction)
attach(Smarket)
?predict()
glm.fit_probs <- predict(glm.fit, type = "response")
glm.fit_probs[1:10]
predict(glm.fit)[1:10]
setwd("~/ISLR")
dir()
LDA.R
#This function is for Linear Discriminant Analysis
#Loading Libraries and preparing Dataset
library(ISLR)
library(MASS)
Smarket <- Smarket
a <- c("The year that the observation was recorded","Percentage return for previous day","Percentage return for 2 days previous","Percentage return for 3 days previous","Percentage return for 4 days previous","Percentage return for 5 days previous","Volume of shares traded (number of daily shares traded in billions)","Percentage return for today","A factor with levels Down and Up indicating whether the market had a positive or negative return on a given day")
Smarket_desc <- data.frame(cbind(colnames(Smarket),a))
colnames(Smarket_desc) <- c("variable","Variable Description")
rm(a)
#Fitting Model for Lag1 and Lag2 and observations before 2005
attach(Smarket)
train <- Year < 2005
lda.fit <- lda(Direction ~ Lag1 + Lag2, data = Smarket, subset = train)
lda.fit
summary(lda.fit)
plot(lda.fot)
plot(lda.fit)
lda.fit
Smarket_2005 <- Smarket[!train,]
lda.fit_preds <- predict(lda.fit, Smarket_2005)
class(lda.fit_preds)
dim(lda.fit_preds)
dim(lda.fit_preds[[1]])
lda.fit_preds[[1]]
class(lda.fit_preds[[1]])
length(lda.fit_preds[[1]])
class(lda.fit_preds[[2]])
dim(lda.fit_preds[[2]])
lda.fit_preds[[2]]
head(lda.fit_preds[[2]],10)
a <- cbind(lda.fit_preds[[2]],lda.fit_preds[[1]])
head(a,10)
class(a)
a <- data.frame(lda.fit_preds[[2]],lda.fit_preds[[1]])
head(a,10)
tail(a,10)
class(lda.fit_preds[[3]])
dim(lda.fit_preds[[3]])
head(lda.fit_preds[[3]],10)
names(lda.fit_preds)
lda.fit
length(Smarket_2005$Lag1)
a <- cbind(Smarket_2005$Lag1,a)
head(a,10)
a <- cbind(Smarket_2005$Lag1,Smarket_2005$Lag2,a[2:4])
head(a,10)
colnames(a) <- c("Lag1","Lag2","P(Down)","P(Up)","Prediction")
head(a,10)
a <- cbind(a, lda.fit_preds[[3]])
head(a,10)
lda.fit
head(a,10)
-0.6420190*(-0.134)-0.5135293*(0.008)
names(lda.fit_preds)
lda.fit_preds_summary <- data.frame(Smarket$Lag1,Smarket$Lag2,lda.fit_preds[[2]],lda.fit_preds[[1]],lda.fit_preds[[3]])
lda.fit_preds_summary <- data.frame(Smarket_2005$Lag1,Smarket_2005$Lag2,lda.fit_preds[[2]],lda.fit_preds[[1]],lda.fit_preds[[3]])
colnames(lda.fit_preds_summary) <- c("Lag1","Lag2","P(Down)","P(Up)","Prediction","Discriminant")
lda.fit_preds_summary
head(lda.fit_preds_summary,10)
summary(lda.fit_preds_summary,10)
lda.fit_conf <- addmargins(table(lda.fit_preds$class,Smarket_2005$Direction))
class(lda.fit_conf)
lda.fit_conf
lda.fit_Error <- (lda.fit_conf[2,1]+lda.fit_conf[1,2])/lda.fit_conf[3,3]
lda.fit_Error
lda.fit_TPR <- lda.fit_conf[2,2]/lda.fit_conf[3,2]
Direction_2005 <- Smarket_2005$Direction
lda.fit_class <- lda.fit_preds$class
lda.fit_conf <- addmargins(table(Actual,Prediction))
Actual <- Smarket_2005$Direction
Prediction <- lda.fit_preds$class
lda.fit_conf <- addmargins(table(Actual,Prediction))
lda.fit_conf
rm(list= c(Actual,Prediction))
rm(list= c("Actual","Prediction"))
lda.fit_FPR <- lda.fit_conf[1,2]/lda.fit_conf[1,3]
lda.fit_preds$posterior[1:20,1]
data.frame(lda.fit_preds$posterior[1:20,1],lda.fit_preds$class[1:20])
data.frame(lda.fit_preds$posterior[1:10,1],lda.fit_preds$class[1:10])
data.frame(lda.fit_preds$posterior[1:20,1],lda.fit_preds$class[1:20])
sum(lda.fit_preds$posterior[,1] > 0.9)
a <- ls()
rm(list = a)
rm(a)
#Preparing Dataset
Smarket <- Smarket
a <- c("The year that the observation was recorded","Percentage return for previous day","Percentage return for 2 days previous","Percentage return for 3 days previous","Percentage return for 4 days previous","Percentage return for 5 days previous","Volume of shares traded (number of daily shares traded in billions)","Percentage return for today","A factor with levels Down and Up indicating whether the market had a positive or negative return on a given day")
Smarket_desc <- data.frame(cbind(colnames(Smarket),a))
colnames(Smarket_desc) <- c("variable","Variable Description")
rm(a)
attach(Smarket)
train <- Year < 2005
Smarket_2005 <- Smarket[!train,]
glm.fit2 <- glm(Direction ~ . -Year -Today, data = Smarket, family = binomial, subset = train)
summary(glm.fit2)$coefficients
glm.fit2_probs <- predict(glm.fit2, type = "response")
glm.fit2_preds <- rep("Down", length(glm.fit2_probs))
glm.fit2_preds[glm.fit2_probs > 0.5] = "Up"
Direction_2001 <- Direction[train]
Direction_2005 <- Direction[!train]
#Creating confusion matrix
glm.fit2_conf <- addmargins(table(glm.fit2_preds, Direction_2001))
glm.fit2_conf
glm.fit2_conf
k <- glm.fit2_conf
a <- ls()
a\
a
grep("k$",a)
a <- a[-7]
a
rm(list=1)
rm(list=a)
rm(a)
#This function is for Linear Discriminant Analysis
#Loading Libraries and preparing Dataset
library(ISLR)
library(MASS)
Smarket <- Smarket
a <- c("The year that the observation was recorded","Percentage return for previous day","Percentage return for 2 days previous","Percentage return for 3 days previous","Percentage return for 4 days previous","Percentage return for 5 days previous","Volume of shares traded (number of daily shares traded in billions)","Percentage return for today","A factor with levels Down and Up indicating whether the market had a positive or negative return on a given day")
Smarket_desc <- data.frame(cbind(colnames(Smarket),a))
colnames(Smarket_desc) <- c("variable","Variable Description")
rm(a)
#Fitting Model for Lag1 and Lag2 and observations before 2005
attach(Smarket)
train <- Year < 2005
lda.fit <- lda(Direction ~ Lag1 + Lag2, data = Smarket, subset = train)
lda.fit
#LDA coefficients provide the values of the linear discriminants such that d(x) =-0.64(X1)-0.51(X2) or d(x)=[Lag1 Lag2]T.[-0.64 -0.51]
#Making Predictions on test data
Smarket_2005 <- Smarket[!train,]
lda.fit_preds <- predict(lda.fit, Smarket_2005)
lda.fit_preds_summary <- data.frame(Smarket_2005$Lag1,Smarket_2005$Lag2,lda.fit_preds[[2]],lda.fit_preds[[1]],lda.fit_preds[[3]])
colnames(lda.fit_preds_summary) <- c("Lag1","Lag2","P(Down)","P(Up)","Prediction","Discriminant")
#Checking Errors
Actual <- Smarket_2005$Direction
Prediction <- lda.fit_preds$class
lda.fit_conf <- addmargins(table(Actual,Prediction))
rm(list= c("Actual","Prediction"))
lda.fit_conf
k
lda.fit_conf <- addmargins(table(Prediction,Actual))
Actual <- Smarket_2005$Direction
Prediction <- lda.fit_preds$class
lda.fit_conf <- addmargins(table(Prediction,Actual))
lda.fit_conf
